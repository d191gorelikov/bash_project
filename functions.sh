#!/bin/bash

cpu()  {  #Количество ядер (пример из подсказки)
	cores=$(grep -c '^processor' /proc/cpuinfo)
	echo "===================== Информация о процессоре =============================="
	echo -e "Количество ядер процессора : $cores"
	echo "============================================================================"

}

memory() {   #Возможно можно было как-то еще реализовать, но этом вариант показался удачным
	mem=($(grep -E "MemTotal|MemFree" /proc/meminfo | cut -d ':' -f2))
	mb=$((mem[0]/1024))
	mb2=$((mem[2]/1024))
	echo "==================== Информация об оперативной памяти ======================"
	echo "Объём оперативной в системе: ${mem[0]}${mem[1]}($mb"Mb")"
	echo -e "Количество использованной оперативной памяти:  ${mem[2]}${mem[3]}($mb2"Mb")"
	echo "============================================================================"



}

tim()  { #Тут все достаточно просто
	date_time=$(date +%H:%M:%S)
	echo "==================== Информация о времени =================================="
	echo -e "Текущее время в системе  $date_time"
	echo "============================================================================"
}


loadavg() { #Решил делать через массив, хотя можно было и через awk, но до этого я додумался потом, хотел переделать, но уже было поздно
	avg=($(cat /proc/loadavg))
	echo "==================== Информация о средней загрузке ========================="
	echo "Средняя загрузка за последнюю минуту (1 минута): ${avg[0]}"
	echo "Средняя загрузка за последние 5 минут (5 минут): ${avg[1]}"
	echo -e "Средняя загрузка за последние 15 минут (15 минут): ${avg[2]}"
        echo "============================================================================"


}


upti() { # Тут тоже все достаточно просто
    h=$(uptime | awk '{print $3}' | cut -d ":" -f1) #выводим часы
    m=$(uptime | awk '{print $3}' | cut -d ":" -f2 | sed 's/,$//') #Выводим минуты и удаляем запятую в конце строки
        echo "==================== Информация о времени работы ==========================="
        echo -e "Время работы системы: $h часов, $m минут"
        echo "============================================================================"

}


listenport() { 
	ports=$(ss -tuln | awk '/LISTEN/ {print $5}' | cut -d ':' -f2) #вывел порт, потом с помощью awk выделил порты в состоянии Listen и отделил ip от порта с помощью cut
	echo "==================== Информация о портах ==================================="
	echo -e  "Список прослушивающих портов:\n$ports"
	echo "============================================================================"
}


disks() {#Далось мне достаточно трудно, по сути это пример из интернета, можно тоже было бы использовать awk, но мне показалось, что можно и оставить в таком виде т.к так выглядит и массивнее и надежнее, но думаю, что это можно было бы сократить
    dhf=($(df -h | grep -E '^/dev/' | awk '{print $1, $2, 100 - $5"%"}'))
        echo "==================== Информация о дисках  =================================="
    for ((i; i < ${#dhf[@]}; i=i+3)); do
        disk=${dhf[i]}
        size=${dhf[i+1]}
        free_space=${dhf[i+2]}
	echo "--------------------------------------------------------"
        echo "Диск: $disk"
        echo "Размер: $size"
        echo "Свободное пространство: $free_space"
    done
        echo "=============================================================================="

}




#Я эту функцию делал 2 дня....Это единственный вариант, который у меня сработал. Вообще это был однострочник, но я попытался привезти в нормальный вид. Честно, не знаю правильный ли это вариант решения
ipadd () { 
	echo "==================== Информация о интерфейсах  =================================="
       ip -s addr show | awk '/^[0-9]/ {              
            printf "Интерфейс: " $2 "\n";
        }
          /state/ {
            print "Статус: " $9;
        }
         /inet / {
            print "IP-адрес: " $2;
        }
         /RX:/ {
           getline; 
            print "Количество отправленных пакетов: " $2;
           print "Количество ошибок на приеме: " $4;
        }
         /TX:/ {
           getline; 
          print "Количество переданных пакетов: " $2;
          print "Количество ошибок на передаче: " $4 "\n----------------------------";
         }'
}


whoac () { # Ну тут все достаточно просто
	echo "================== Информация об активных пользователях в системе =============="
	who | awk '{print "Пользователь:" $1} {print "Рабочий терминал пользователя:" $2"\n------------------------------"}'
}


alluser() { # Так же, как и в cut, выбрал :/UID больше или равен 1000(пользовательские значения) и вывел отдельно пользователя root
#Учетку nobody так и не смог убрать 
	echo "================== Список пользователей в системе =============================="
	cat /etc/passwd | awk -F ":" '$3 >= 1000 || $3==0 && $3!=65534 {print $1"\n-----------------"}' #только пользовательские учетки и root, не смог исключить учетку nobody
	echo "!!!Исключены служеные и системные учетки!!!"
}



ruser() { #Тут нашел группу sudo в /etc/group и вывел список учеток с правами администратора
	echo "================== Список root-пользователей в системе =============================="
        echo "(пользователи группы sudo)"
        IFS=","
        group=($(sudo cat /etc/group | grep sudo | cut -d : -f4))
        for i in "${group[@]}"; do
        echo -e "$i\n-----------------------------"
        done
}


helpinfo() { #Это то, что выводит опция --help
  echo "Использование: pr.sh [опции]"
  echo "Опции:"
  echo "  --host              Показать информацию о хосте"
  echo "  --user              Показать информацию о пользователях"
  echo "  --help              Показать информацию о поддерживаемых параметрах"
}


checkroot() { #Проверяем является ли пользователь рутом или скрипт не будет работать

	if [[ $EUID -ne 0 ]]; then
   echo "Этот скрипт должен быть запущен с правами суперпользователя."
   exit 1
fi
}

helpnull() { #Эту функцию пришлось прописать в файле script.sh полностью т.к если вызывать её из этого файла, то скрипт выдает всегда информацию из опции --help
	if [[ $# -eq 0 ]]; then
  helpinfo
  exit 0
fi
}

